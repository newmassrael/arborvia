# ArborVia - ì•„í‚¤í…ì²˜ ë¬¸ì„œ

> **ê³„ì¸µì  ê·¸ë˜í”„ ë ˆì´ì•„ì›ƒì„ ìœ„í•œ ê²½ëŸ‰ C++ ë¼ì´ë¸ŒëŸ¬ë¦¬**

---

## ğŸ“Š êµ¬í˜„ ìƒíƒœ

| ìƒíƒœ | ì˜ë¯¸ |
|------|------|
| âœ… êµ¬í˜„ ì™„ë£Œ | í”„ë¡œë•ì…˜ ì‚¬ìš© ê°€ëŠ¥, í…ŒìŠ¤íŠ¸ ì™„ë£Œ |
| ğŸš§ êµ¬í˜„ ì¤‘ | ê°œë°œ ì§„í–‰ ì¤‘ |
| ğŸ“‹ ì„¤ê³„ ì™„ë£Œ | ì„¤ê³„ëŠ” ì™„ë£Œ, êµ¬í˜„ ì˜ˆì • |
| ğŸ“ ê³„íšë¨ | í–¥í›„ êµ¬í˜„ ê³„íš |

**í˜„ì¬ ìƒíƒœ ìš”ì•½:**
- **core/** âœ… êµ¬í˜„ ì™„ë£Œ - Graph, CompoundGraph, Types
- **layout/** âœ… êµ¬í˜„ ì™„ë£Œ - SugiyamaLayout
- **export/** âœ… êµ¬í˜„ ì™„ë£Œ - SvgExport
- **routing/** ğŸ“‹ ì„¤ê³„ ì™„ë£Œ - IEdgeRouter, OrthogonalRouter (êµ¬í˜„ ì˜ˆì •)

---

## ğŸ¯ í•µì‹¬ ì² í•™

```
"ì™¸ë¶€ ì˜ì¡´ì„± ì—†ì´ ìˆœìˆ˜ C++ë¡œ êµ¬í˜„ëœ ê·¸ë˜í”„ ë ˆì´ì•„ì›ƒ ì—”ì§„"
```

**í•µì‹¬ ì›ì¹™:**
1. **ì œë¡œ ì˜ì¡´ì„±** - C++ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë§Œ ì‚¬ìš©
2. **ë‹¨ì¼ ì±…ì„** - ê·¸ë˜í”„ ë ˆì´ì•„ì›ƒë§Œ ë‹´ë‹¹, ë Œë”ë§ì€ ì‚¬ìš©ì ëª«
3. **MIT ë¼ì´ì„¼ìŠ¤** - ìƒì—…ìš© ê²Œì„ì—ì„œ ììœ ë¡­ê²Œ ì‚¬ìš© ê°€ëŠ¥
4. **í”Œë«í¼ ë…ë¦½ì ** - SDL, ImGui, Qt ë“± ì–´ë–¤ UI í”„ë ˆì„ì›Œí¬ì™€ë„ í†µí•© ê°€ëŠ¥

---

## ğŸ”§ ì„¤ê³„ ëª©í‘œ

**ArborViaëŠ” ë‹¤ìŒì„ ìœ„í•´ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤:**

1. **ìƒíƒœë¨¸ì‹  ì—ë””í„°** - SCXML/FSM ì‹œê°í™”
2. **ì›Œí¬í”Œë¡œìš° ë‹¤ì´ì–´ê·¸ë¨** - í”„ë¡œì„¸ìŠ¤ íë¦„ í‘œí˜„
3. **ê³„ì¸µì  ê·¸ë˜í”„** - ì¡°ì§ë„, íŠ¸ë¦¬ êµ¬ì¡° ë“±
4. **Compound/Parallel ë…¸ë“œ** - ì¤‘ì²© ìƒíƒœ ë° ë³‘ë ¬ ìƒíƒœ ì§€ì›

**ì™œ ArborViaì¸ê°€?**
- ELK.jsëŠ” WASMìœ¼ë¡œ ì‚¬ìš©í•˜ë©´ 45-55% ì„±ëŠ¥ ì €í•˜
- OGDFëŠ” GPL ë¼ì´ì„¼ìŠ¤ë¡œ ìƒì—…ìš© ê²Œì„ì—ì„œ ì‚¬ìš© ë¶ˆê°€
- ë„¤ì´í‹°ë¸Œ C++ë¡œ ìµœì ì˜ ì„±ëŠ¥ê³¼ ììœ ë¡œìš´ ë¼ì´ì„¼ìŠ¤ ì œê³µ

---

## ğŸ—ï¸ ì•„í‚¤í…ì²˜ ë ˆì´ì–´

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ë ˆì´ì–´ 1: ì‚¬ìš©ì ì• í”Œë¦¬ì¼€ì´ì…˜ (ArborVia ì™¸ë¶€)       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ SDL3+ImGui  â”‚  â”‚    Qt       â”‚  â”‚   Custom    â”‚ â”‚
â”‚  â”‚  (ê²Œì„ UI)  â”‚  â”‚  (ë°ìŠ¤í¬íƒ‘) â”‚  â”‚   (ì›¹ ë“±)   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ë ˆì´ì–´ 2: ì¶œë ¥ ëª¨ë“ˆ (export/) âœ…                   â”‚
â”‚  - IExporter ì¸í„°í˜ì´ìŠ¤                             â”‚
â”‚  - SvgExport (SVG íŒŒì¼ ë‚´ë³´ë‚´ê¸°)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ë ˆì´ì–´ 3: ë¼ìš°íŒ… ëª¨ë“ˆ (routing/) ğŸ“‹                â”‚
â”‚  - IEdgeRouter ì¸í„°í˜ì´ìŠ¤ (ì„¤ê³„ ì™„ë£Œ)               â”‚
â”‚  - OrthogonalRouter (êµ¬í˜„ ì˜ˆì •)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ë ˆì´ì–´ 4: ë ˆì´ì•„ì›ƒ ì—”ì§„ (layout/) âœ…               â”‚
â”‚  - ILayout ì¸í„°í˜ì´ìŠ¤                               â”‚
â”‚  - SugiyamaLayout (Sugiyama ì•Œê³ ë¦¬ì¦˜)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ë ˆì´ì–´ 5: í•µì‹¬ ìë£Œêµ¬ì¡° (core/) âœ…                 â”‚
â”‚  - Graph (ê¸°ë³¸ ìœ í–¥ ê·¸ë˜í”„)                         â”‚
â”‚  - CompoundGraph (ê³„ì¸µì  ê·¸ë˜í”„)                    â”‚
â”‚  - LayoutOptions / LayoutResult                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ë ˆì´ì–´ 6: ê¸°ë°˜ íƒ€ì… âœ…                             â”‚
â”‚  - Types (Point, Size, Rect)                        â”‚
â”‚  - NodeId, EdgeId                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ì˜ì¡´ì„± íë¦„: ìœ„ â†’ ì•„ë˜ (ë‹¨ë°©í–¥ë§Œ)
```

---

## ğŸ“¦ ëª¨ë“ˆ êµ¬ì¡°

### í˜„ì¬ êµ¬í˜„ëœ êµ¬ì¡° âœ…

```
arborvia/
â”œâ”€â”€ include/arborvia/           # ê³µê°œ í—¤ë”
â”‚   â”œâ”€â”€ arborvia.h              # ë©”ì¸ í—¤ë” (ëª¨ë“  ëª¨ë“ˆ í¬í•¨)
â”‚   â”œâ”€â”€ core/                   # âœ… í•µì‹¬ ìë£Œêµ¬ì¡°
â”‚   â”‚   â”œâ”€â”€ Types.h             # Point, Size, Rect, NodeId, EdgeId
â”‚   â”‚   â”œâ”€â”€ Graph.h             # ê¸°ë³¸ ê·¸ë˜í”„ í´ë˜ìŠ¤
â”‚   â”‚   â””â”€â”€ CompoundGraph.h     # ê³„ì¸µì  ê·¸ë˜í”„ í´ë˜ìŠ¤
â”‚   â”œâ”€â”€ layout/                 # âœ… ë ˆì´ì•„ì›ƒ ì—”ì§„
â”‚   â”‚   â”œâ”€â”€ ILayout.h           # ë ˆì´ì•„ì›ƒ ì¸í„°í˜ì´ìŠ¤
â”‚   â”‚   â”œâ”€â”€ LayoutOptions.h     # ë ˆì´ì•„ì›ƒ ì„¤ì •
â”‚   â”‚   â”œâ”€â”€ LayoutResult.h      # ë ˆì´ì•„ì›ƒ ê²°ê³¼
â”‚   â”‚   â”œâ”€â”€ LayoutTypes.h       # LayoutMode, NodeEdge, SnapPointConfig ë“±
â”‚   â”‚   â”œâ”€â”€ LayoutUtils.h       # ë ˆì´ì•„ì›ƒ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
â”‚   â”‚   â”œâ”€â”€ ManualLayoutManager.h # ìˆ˜ë™ ë ˆì´ì•„ì›ƒ ê´€ë¦¬ì
â”‚   â”‚   â””â”€â”€ SugiyamaLayout.h    # Sugiyama ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
â”‚   â””â”€â”€ export/                 # âœ… ë‚´ë³´ë‚´ê¸° ëª¨ë“ˆ
â”‚       â”œâ”€â”€ IExporter.h         # ë‚´ë³´ë‚´ê¸° ì¸í„°í˜ì´ìŠ¤
â”‚       â””â”€â”€ SvgExport.h         # SVG ë‚´ë³´ë‚´ê¸° êµ¬í˜„
â”œâ”€â”€ src/                        # êµ¬í˜„ íŒŒì¼
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ Graph.cpp
â”‚   â”‚   â””â”€â”€ CompoundGraph.cpp
â”‚   â”œâ”€â”€ layout/
â”‚   â”‚   â”œâ”€â”€ LayoutResult.cpp
â”‚   â”‚   â”œâ”€â”€ LayoutUtils.cpp
â”‚   â”‚   â”œâ”€â”€ ManualLayoutManager.cpp
â”‚   â”‚   â”œâ”€â”€ SugiyamaLayout.cpp
â”‚   â”‚   â””â”€â”€ sugiyama/           # Sugiyama ë‚´ë¶€ ì•Œê³ ë¦¬ì¦˜
â”‚   â”‚       â”œâ”€â”€ CycleRemoval.cpp
â”‚   â”‚       â”œâ”€â”€ LayerAssignment.cpp
â”‚   â”‚       â”œâ”€â”€ CrossingMinimization.cpp
â”‚   â”‚       â”œâ”€â”€ CoordinateAssignment.cpp
â”‚   â”‚       â””â”€â”€ EdgeRouting.cpp
â”‚   â””â”€â”€ export/
â”‚       â””â”€â”€ SvgExport.cpp
â”œâ”€â”€ tests/                      # í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ GraphTest.cpp
â”‚   â”‚   â””â”€â”€ CompoundGraphTest.cpp
â”‚   â”œâ”€â”€ layout/
â”‚   â”‚   â”œâ”€â”€ SugiyamaLayoutTest.cpp
â”‚   â”‚   â”œâ”€â”€ LayoutResultTest.cpp
â”‚   â”‚   â””â”€â”€ ManualLayoutTest.cpp
â”‚   â”œâ”€â”€ export/
â”‚   â”‚   â””â”€â”€ SvgExportTest.cpp
â”‚   â””â”€â”€ interactive/
â”‚       â””â”€â”€ DragBehaviorTest.cpp
â”œâ”€â”€ examples/                   # ì˜ˆì œ í”„ë¡œê·¸ë¨
â”‚   â”œâ”€â”€ interactive_demo/       # ì¸í„°ë™í‹°ë¸Œ ë°ëª¨
â”‚   â”‚   â””â”€â”€ main.cpp
â”‚   â”œâ”€â”€ drag_demo/              # ë“œë˜ê·¸ ê¸°ëŠ¥ ë°ëª¨
â”‚   â”‚   â””â”€â”€ main.cpp
â”‚   â””â”€â”€ visual_demo/            # ì‹œê°ì  í…ŒìŠ¤íŠ¸ ë°ëª¨
â”‚       â””â”€â”€ main.cpp
â”œâ”€â”€ cmake/                      # ëª¨ë“ˆë³„ CMake ì„¤ì •
â”‚   â”œâ”€â”€ ArborviaCore.cmake
â”‚   â”œâ”€â”€ ArborviaLayout.cmake
â”‚   â””â”€â”€ ArborviaExport.cmake
â”œâ”€â”€ CMakeLists.txt              # ë©”ì¸ ë¹Œë“œ ì„¤ì •
â””â”€â”€ docs/
    â””â”€â”€ ko/
        â””â”€â”€ ARCHITECTURE.md
```

### ê³„íšëœ êµ¬ì¡° ğŸ“‹ (routing ëª¨ë“ˆ)

```
include/arborvia/
â””â”€â”€ routing/                    # ğŸ“‹ ì—£ì§€ ë¼ìš°íŒ… ëª¨ë“ˆ (êµ¬í˜„ ì˜ˆì •)
    â”œâ”€â”€ IEdgeRouter.h           # ë¼ìš°íŒ… ì¸í„°í˜ì´ìŠ¤
    â”œâ”€â”€ EdgeRoutingConfig.h     # ì—£ì§€ë³„ ë¼ìš°íŒ… ì„¤ì •
    â””â”€â”€ OrthogonalRouter.h      # ì§êµ ë¼ìš°íŒ… êµ¬í˜„

src/routing/
â”œâ”€â”€ OrthogonalRouter.cpp
â””â”€â”€ SnapPointAllocator.cpp

tests/routing/
â””â”€â”€ EdgeRoutingTest.cpp
```

**ëª¨ë“ˆ ì˜ì¡´ì„± ê·œì¹™:**
```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   export    â”‚
                    â”‚ (IExporter) â”‚
                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                      â”‚                      â”‚
    â–¼                      â–¼                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ routing â”‚ â”€â”€â”€â”€â”€â”€â–º â”‚   layout    â”‚ â—„â”€â”€â”€â”€â”€ â”‚   export    â”‚
â”‚(IRouter)â”‚         â”‚  (ILayout)  â”‚        â”‚ (IExporter) â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
     â”‚                     â”‚                      â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚    core     â”‚
                    â”‚ (Graph ë“±)  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- `core/`ëŠ” ì˜ì¡´ì„± ì—†ìŒ (ê¸°ë°˜ ëª¨ë“ˆ)
- `layout/`ì€ `core/`ì— ì˜ì¡´
- `routing/`ì€ `core/`, `layout/`ì— ì˜ì¡´
- `export/`ëŠ” `core/`, `layout/`ì— ì˜ì¡´

---

## ğŸ“Š ë ˆì´ì–´ 5: ê¸°ë°˜ íƒ€ì…

**ìˆœìˆ˜ ë°ì´í„° íƒ€ì… - ì˜ì¡´ì„± ì—†ìŒ**

### Types.h

```cpp
namespace arborvia {

using NodeId = uint32_t;
using EdgeId = uint32_t;

constexpr NodeId INVALID_NODE = UINT32_MAX;
constexpr EdgeId INVALID_EDGE = UINT32_MAX;

struct Point {
    float x = 0.0f;
    float y = 0.0f;
    
    Point operator+(const Point& o) const;
    Point operator-(const Point& o) const;
    float length() const;
    float distanceTo(const Point& o) const;
};

struct Size {
    float width = 0.0f;
    float height = 0.0f;
};

struct Rect {
    float x, y, width, height;
    
    Point center() const;
    bool contains(const Point& p) const;
    Rect united(const Rect& other) const;
    Rect expanded(float padding) const;
};

}
```

**í•µì‹¬:** ë Œë”ë§ í”„ë ˆì„ì›Œí¬ ì˜ì¡´ì„± ì—†ìŒ. ìˆœìˆ˜ ìˆ˜í•™ì  íƒ€ì….

---

## ğŸ”Œ ì¸í„°í˜ì´ìŠ¤ ì„¤ê³„

**í™•ì¥ì„±ì„ ìœ„í•œ ì¶”ìƒ ì¸í„°í˜ì´ìŠ¤**

### ILayout (layout/ILayout.h)

```cpp
namespace arborvia {

/// ë ˆì´ì•„ì›ƒ ì•Œê³ ë¦¬ì¦˜ì˜ ì¶”ìƒ ì¸í„°í˜ì´ìŠ¤
class ILayout {
public:
    virtual ~ILayout() = default;
    
    /// ë ˆì´ì•„ì›ƒ ì˜µì…˜ ì„¤ì •
    virtual void setOptions(const LayoutOptions& options) = 0;
    virtual const LayoutOptions& options() const = 0;
    
    /// ê¸°ë³¸ ê·¸ë˜í”„ ë ˆì´ì•„ì›ƒ
    virtual LayoutResult layout(const Graph& graph) = 0;
    
    /// ê³„ì¸µì  ê·¸ë˜í”„ ë ˆì´ì•„ì›ƒ
    virtual LayoutResult layout(const CompoundGraph& graph) = 0;
};

}
```

### IExporter (export/IExporter.h)

```cpp
namespace arborvia {

/// ë‚´ë³´ë‚´ê¸° í¬ë§·ì˜ ì¶”ìƒ ì¸í„°í˜ì´ìŠ¤
class IExporter {
public:
    virtual ~IExporter() = default;
    
    /// ë¬¸ìì—´ë¡œ ë‚´ë³´ë‚´ê¸°
    virtual std::string exportToString(const Graph& graph, 
                                       const LayoutResult& layout) = 0;
    virtual std::string exportToString(const CompoundGraph& graph,
                                       const LayoutResult& layout) = 0;
    
    /// ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë‚´ë³´ë‚´ê¸°
    virtual void exportToStream(const Graph& graph, const LayoutResult& layout,
                               std::ostream& out) = 0;
    
    /// íŒŒì¼ë¡œ ë‚´ë³´ë‚´ê¸°
    virtual bool exportToFile(const Graph& graph, const LayoutResult& layout,
                             const std::string& filename) = 0;
    
    /// ë©”íƒ€ë°ì´í„°
    virtual std::string fileExtension() const = 0;
    virtual std::string mimeType() const = 0;
};

}
```

### IEdgeRouter (routing/IEdgeRouter.h) ğŸ“‹ ì„¤ê³„ ì™„ë£Œ

> **ìƒíƒœ:** ì„¤ê³„ ì™„ë£Œ, êµ¬í˜„ ì˜ˆì •. ì•„ë˜ëŠ” ì„¤ê³„ ëª…ì„¸ì…ë‹ˆë‹¤.

```cpp
namespace arborvia {

/// ì—£ì§€ ë¼ìš°íŒ… ì•Œê³ ë¦¬ì¦˜ì˜ ì¶”ìƒ ì¸í„°í˜ì´ìŠ¤
/// ì„¤ê³„ ì›ì¹™: Primitive APIë§Œ ì œê³µ, í¸ì˜ ê¸°ëŠ¥ì€ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ì¡°í•©
class IEdgeRouter {
public:
    virtual ~IEdgeRouter() = default;
    
    /// ë¼ìš°íŒ… ì˜µì…˜ ì„¤ì •
    virtual void setOptions(const EdgeRoutingOptions& options) = 0;
    virtual const EdgeRoutingOptions& options() const = 0;
    
    /// [Primitive] ë‹¨ì¼ ì—£ì§€ ë¼ìš°íŒ…
    virtual EdgeLayout route(
        const EdgeData& edge,
        const NodeLayout& from,
        const NodeLayout& to,
        const EdgeRoutingConfig* config = nullptr) = 0;
    
    /// [Batch] ì„ íƒëœ ì—£ì§€ë“¤ ë¼ìš°íŒ… (ìµœì í™”ëœ ë°°ì¹˜ ì²˜ë¦¬)
    virtual std::unordered_map<EdgeId, EdgeLayout> routeEdges(
        const std::vector<EdgeId>& edgeIds,
        const Graph& graph,
        const std::unordered_map<NodeId, NodeLayout>& nodeLayouts,
        const std::unordered_map<EdgeId, EdgeRoutingConfig>* configs = nullptr) = 0;
    
    /// [Batch] ì „ì²´ ì—£ì§€ ë¼ìš°íŒ…
    virtual std::unordered_map<EdgeId, EdgeLayout> routeAll(
        const Graph& graph,
        const std::unordered_map<NodeId, NodeLayout>& nodeLayouts,
        const std::unordered_map<EdgeId, EdgeRoutingConfig>* configs = nullptr) = 0;
};

}
```

**í•µì‹¬:** ì¸í„°í˜ì´ìŠ¤ ê¸°ë°˜ ì„¤ê³„ë¡œ ìƒˆë¡œìš´ ì•Œê³ ë¦¬ì¦˜ ì¶”ê°€ ìš©ì´

---

## ğŸ“ˆ ë ˆì´ì–´ 5: ê·¸ë˜í”„ ìë£Œêµ¬ì¡°

**ê·¸ë˜í”„ ë°ì´í„° ê´€ë¦¬ - ë ˆì´ì•„ì›ƒ ì•Œê³ ë¦¬ì¦˜ê³¼ ë¶„ë¦¬**

### Graph (ê¸°ë³¸ ê·¸ë˜í”„)

```cpp
class Graph {
public:
    // ë…¸ë“œ ê´€ë¦¬
    NodeId addNode();
    NodeId addNode(const std::string& label);
    NodeId addNode(Size size, const std::string& label);
    void removeNode(NodeId id);
    
    // ì—£ì§€ ê´€ë¦¬
    EdgeId addEdge(NodeId from, NodeId to);
    EdgeId addEdge(NodeId from, NodeId to, const std::string& label);
    void removeEdge(EdgeId id);
    
    // ë…¸ë“œ ì—°ê²° ì¿¼ë¦¬
    std::vector<NodeId> successors(NodeId id) const;
    std::vector<NodeId> predecessors(NodeId id) const;
    std::optional<EdgeId> findEdge(NodeId from, NodeId to) const;
    
    // ì—£ì§€ ì¿¼ë¦¬ (ë¼ìš°íŒ… ëª¨ë“ˆ ì—°ë™ìš©)
    std::vector<EdgeId> getOutEdges(NodeId id) const;       // ë‚˜ê°€ëŠ” ì—£ì§€
    std::vector<EdgeId> getInEdges(NodeId id) const;        // ë“¤ì–´ì˜¤ëŠ” ì—£ì§€
    std::vector<EdgeId> getConnectedEdges(NodeId id) const; // ëª¨ë“  ì—°ê²°ëœ ì—£ì§€
    
protected:
    std::vector<NodeData> nodes_;
    std::vector<EdgeData> edges_;
    std::unordered_map<NodeId, std::vector<EdgeId>> outEdges_;
    std::unordered_map<NodeId, std::vector<EdgeId>> inEdges_;
};
```

### CompoundGraph (ê³„ì¸µì  ê·¸ë˜í”„)

```cpp
enum class CompoundType {
    Atomic,      // ìì‹ ì—†ìŒ (ë¦¬í”„ ë…¸ë“œ)
    Compound,    // ìˆœì°¨ì  ìì‹ (ì„¸ë¡œ ë ˆì´ì•„ì›ƒ)
    Parallel     // ë³‘ë ¬ ìì‹ (ê°€ë¡œ ë ˆì´ì•„ì›ƒ)
};

class CompoundGraph : public Graph {
public:
    // ê³„ì¸µ ê´€ë¦¬
    void setParent(NodeId child, NodeId parent);
    void removeFromParent(NodeId child);
    
    // ê³„ì¸µ ì¿¼ë¦¬
    std::optional<NodeId> getParent(NodeId id) const;
    std::vector<NodeId> getChildren(NodeId id) const;
    std::vector<NodeId> getDescendants(NodeId id) const;
    std::vector<NodeId> getAncestors(NodeId id) const;
    
    // íƒ€ì… ì¿¼ë¦¬
    bool isCompound(NodeId id) const;
    bool isParallel(NodeId id) const;
    bool isAtomic(NodeId id) const;
    bool isRoot(NodeId id) const;
    
    // ì ‘ê¸°/í¼ì¹˜ê¸°
    void setCollapsed(NodeId id, bool collapsed);
    bool isCollapsed(NodeId id) const;
    bool isVisible(NodeId id) const;
    
    // ìœ í‹¸ë¦¬í‹°
    std::optional<NodeId> lowestCommonAncestor(NodeId a, NodeId b) const;
};
```

**í•µì‹¬:** ê·¸ë˜í”„ êµ¬ì¡°ë§Œ ê´€ë¦¬. ìœ„ì¹˜ ì •ë³´ ì—†ìŒ.

---

## âš™ï¸ ë ˆì´ì–´ 3: ë ˆì´ì•„ì›ƒ ì—”ì§„

**Sugiyama ì•Œê³ ë¦¬ì¦˜ - 5ë‹¨ê³„ ë ˆì´ì•„ì›ƒ í”„ë¡œì„¸ìŠ¤**

### Sugiyama ì•Œê³ ë¦¬ì¦˜ íŒŒì´í”„ë¼ì¸

```
ì…ë ¥: Graph/CompoundGraph
          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Cycle Removal                â”‚
â”‚    - DFSë¡œ ë°±ì—£ì§€ íƒì§€          â”‚
â”‚    - ì‚¬ì´í´ í˜•ì„± ì—£ì§€ ì—­ì „ ë§ˆí‚¹  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. Layer Assignment             â”‚
â”‚    - Longest Path ì•Œê³ ë¦¬ì¦˜      â”‚
â”‚    - ê° ë…¸ë“œì— ë ˆì´ì–´ ë²ˆí˜¸ í• ë‹¹  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. Crossing Minimization        â”‚
â”‚    - Barycenter Heuristic       â”‚
â”‚    - ë ˆì´ì–´ ë‚´ ë…¸ë“œ ìˆœì„œ ìµœì í™”  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. Coordinate Assignment        â”‚
â”‚    - ì‹¤ì œ x, y ì¢Œí‘œ ê³„ì‚°        â”‚
â”‚    - ë…¸ë“œ í¬ê¸° ë° ê°„ê²© ê³ ë ¤      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. Edge Routing                 â”‚
â”‚    - Orthogonal (ì§êµ) ë¼ìš°íŒ…   â”‚
â”‚    - Polyline ë¼ìš°íŒ…            â”‚
â”‚    - ë²¤ë“œ í¬ì¸íŠ¸ ê³„ì‚°            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â†“
ì¶œë ¥: LayoutResult
```

### SugiyamaLayout í´ë˜ìŠ¤

```cpp
class SugiyamaLayout {
public:
    SugiyamaLayout();
    explicit SugiyamaLayout(const LayoutOptions& options);
    
    // ë ˆì´ì•„ì›ƒ ì‹¤í–‰
    LayoutResult layout(const Graph& graph);
    LayoutResult layout(const CompoundGraph& graph);
    
    // í†µê³„
    struct LayoutStats {
        int layerCount;
        int maxLayerWidth;
        int edgeCrossings;
        int reversedEdges;
        float totalEdgeLength;
    };
    const LayoutStats& lastStats() const;
    
private:
    void removeCycles();
    void assignLayers();
    void minimizeCrossings();
    void assignCoordinates();
    void routeEdges();
    
    // Compound ê·¸ë˜í”„ ì „ìš©
    void layoutCompoundNode(NodeId id, const CompoundGraph& graph);
    void layoutParallelRegions(NodeId id, const CompoundGraph& graph);
};
```

### LayoutOptions

```cpp
enum class Direction { TopToBottom, BottomToTop, LeftToRight, RightToLeft };
enum class EdgeRouting { Orthogonal, Polyline, Splines };
enum class CrossingMinimization { None, BarycenterHeuristic, MedianHeuristic };

struct LayoutOptions {
    Direction direction = Direction::TopToBottom;
    
    float nodeSpacingHorizontal = 50.0f;
    float nodeSpacingVertical = 75.0f;
    float compoundPadding = 20.0f;
    float parallelSpacing = 30.0f;
    
    EdgeRouting edgeRouting = EdgeRouting::Orthogonal;
    CrossingMinimization crossingMinimization = CrossingMinimization::BarycenterHeuristic;
    int crossingMinimizationPasses = 4;
    
    // Builder íŒ¨í„´
    LayoutOptions& setDirection(Direction d);
    LayoutOptions& setNodeSpacing(float h, float v);
};
```

### LayoutResult

```cpp
struct NodeLayout {
    NodeId id;
    Point position;    // ì¢Œìƒë‹¨ ì¢Œí‘œ
    Size size;
    int layer;         // ë ˆì´ì–´ ì¸ë±ìŠ¤
    int order;         // ë ˆì´ì–´ ë‚´ ìˆœì„œ
    
    Point center() const;
    Rect bounds() const;
};

struct EdgeLayout {
    EdgeId id;
    NodeId from, to;
    Point sourcePoint;
    Point targetPoint;
    std::vector<BendPoint> bendPoints;
    
    std::vector<Point> allPoints() const;
};

class LayoutResult {
public:
    const NodeLayout* getNodeLayout(NodeId id) const;
    const EdgeLayout* getEdgeLayout(EdgeId id) const;
    
    Rect computeBounds() const;
    Rect computeBounds(float padding) const;
    
    void translate(float dx, float dy);
};
```

---

## ğŸ”€ ë ˆì´ì–´ 3: ë¼ìš°íŒ… ëª¨ë“ˆ ğŸ“‹ ì„¤ê³„ ì™„ë£Œ

> **ìƒíƒœ:** ì„¤ê³„ ì™„ë£Œ, êµ¬í˜„ ì˜ˆì •. ì•„ë˜ëŠ” í–¥í›„ êµ¬í˜„ë  API ëª…ì„¸ì…ë‹ˆë‹¤.

**ì—£ì§€ ë¼ìš°íŒ…, ìŠ¤ëƒ… í¬ì¸íŠ¸, í¬íŠ¸ ì œì•½ ê´€ë¦¬**

### ì„¤ê³„ ëª©í‘œ

SCE(SCXML Core Engine)ì˜ visualizer.htmlì—ì„œ ì œê³µí•˜ëŠ” ê¸°ëŠ¥ë“¤ì„ C++ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë ˆë²¨ì—ì„œ ì§€ì›:

1. **ìŠ¤ëƒ… í¬ì¸íŠ¸ (Snap Points)** - ë…¸ë“œ ê²½ê³„ì˜ ì—°ê²°ì  ìë™ ë°°ì¹˜
2. **í¬íŠ¸ ì œì•½ (Port Constraints)** - ì—£ì§€ ì—°ê²° ìœ„ì¹˜ ì œì–´
3. **êº¾ì„ í¬ì¸íŠ¸ (Bend Points)** - ì—£ì§€ ê²½ë¡œì˜ ì¤‘ê°„ ì§€ì 
4. **ì§êµ ë¼ìš°íŒ… (Orthogonal Routing)** - ìˆ˜ì§/ìˆ˜í‰ ì—£ì§€ ê²½ë¡œ

### PortSide ì—´ê±°í˜•

```cpp
namespace arborvia {

/// ë…¸ë“œì˜ ì–´ëŠ ë©´ì— í¬íŠ¸ê°€ ìœ„ì¹˜í•˜ëŠ”ì§€
enum class PortSide {
    Any,        // ìë™ ì„ íƒ
    Top,        // ìƒë‹¨
    Bottom,     // í•˜ë‹¨
    Left,       // ì¢Œì¸¡
    Right,      // ìš°ì¸¡
    Center      // ì¤‘ì•™ (íŠ¹ìˆ˜ ì¼€ì´ìŠ¤)
};

}
```

### PortConstraint

```cpp
namespace arborvia {

/// ë…¸ë“œì— ëŒ€í•œ í¬íŠ¸/ìŠ¤ëƒ… í¬ì¸íŠ¸ ì œì•½
struct PortConstraint {
    NodeId nodeId;
    PortSide side = PortSide::Any;           // ì—°ê²° ë©´
    
    // ì •ë°€ ìœ„ì¹˜ ì§€ì • (0.0 ~ 1.0, ë©´ì˜ ìƒëŒ€ì  ìœ„ì¹˜)
    std::optional<float> position;            // 0.0=ì‹œì‘, 0.5=ì¤‘ì•™, 1.0=ë
    
    // ê³ ì • ì¢Œí‘œ (position ëŒ€ì‹  ì‚¬ìš©)
    std::optional<Point> fixedPoint;
    
    // í¬íŠ¸ ì‹ë³„ì (ì—¬ëŸ¬ í¬íŠ¸ êµ¬ë¶„ìš©)
    std::string portId;
    
    // ë¹Œë” íŒ¨í„´
    PortConstraint& setSide(PortSide s);
    PortConstraint& setPosition(float pos);
    PortConstraint& setFixed(Point p);
};

}
```

### EdgeRoutingConfig

```cpp
namespace arborvia {

/// ê°œë³„ ì—£ì§€ì— ëŒ€í•œ ë¼ìš°íŒ… ì„¤ì •
struct EdgeRoutingConfig {
    EdgeId edgeId;
    
    // ì†ŒìŠ¤/íƒ€ê²Ÿ í¬íŠ¸ ì œì•½
    PortConstraint sourcePort;
    PortConstraint targetPort;
    
    // ë¼ìš°íŒ… íƒ€ì… (ê¸°ë³¸ê°’ì€ ê¸€ë¡œë²Œ ì˜µì…˜ ë”°ë¦„)
    std::optional<EdgeRouting> routingType;
    
    // ìˆ˜ë™ ë²¤ë“œ í¬ì¸íŠ¸ (ìë™ ë¼ìš°íŒ… ëŒ€ì‹  ì‚¬ìš©)
    std::vector<Point> manualBendPoints;
    
    // ë¼ìš°íŒ… ìš°ì„ ìˆœìœ„ (ì¶©ëŒ ì‹œ ì‚¬ìš©)
    int priority = 0;
    
    // ë¹Œë” íŒ¨í„´
    EdgeRoutingConfig& setSource(PortConstraint pc);
    EdgeRoutingConfig& setTarget(PortConstraint pc);
    EdgeRoutingConfig& addBendPoint(Point p);
};

}
```

### EdgeRoutingOptions

```cpp
namespace arborvia {

/// ê¸€ë¡œë²Œ ì—£ì§€ ë¼ìš°íŒ… ì˜µì…˜
struct EdgeRoutingOptions {
    // ê¸°ë³¸ ë¼ìš°íŒ… íƒ€ì…
    EdgeRouting defaultRouting = EdgeRouting::Orthogonal;
    
    // ìŠ¤ëƒ… í¬ì¸íŠ¸ ì„¤ì •
    bool enableSnapPoints = true;
    float snapPointSpacing = 20.0f;          // ìŠ¤ëƒ… í¬ì¸íŠ¸ ê°„ ìµœì†Œ ê°„ê²©
    int maxSnapPointsPerSide = 10;           // ë©´ë‹¹ ìµœëŒ€ ìŠ¤ëƒ… í¬ì¸íŠ¸ ìˆ˜
    
    // ì§êµ ë¼ìš°íŒ… ì„¤ì •
    float orthogonalMargin = 10.0f;          // ë…¸ë“œë¡œë¶€í„°ì˜ ìµœì†Œ ê±°ë¦¬
    float bendPointMinDistance = 15.0f;      // ë²¤ë“œ í¬ì¸íŠ¸ ê°„ ìµœì†Œ ê±°ë¦¬
    
    // ì—£ì§€ ê°„ê²© ì„¤ì •
    float parallelEdgeSpacing = 8.0f;        // í‰í–‰ ì—£ì§€ ê°„ ê°„ê²©
    
    // ì¶©ëŒ íšŒí”¼
    bool avoidNodeOverlap = true;            // ë…¸ë“œ í†µê³¼ ë°©ì§€
    bool avoidEdgeCrossing = false;          // ì—£ì§€ êµì°¨ ìµœì†Œí™” (ë¹„ìš© ë†’ìŒ)
    
    // ë¹Œë” íŒ¨í„´
    EdgeRoutingOptions& setSnapSpacing(float spacing);
    EdgeRoutingOptions& setOrthogonalMargin(float margin);
};

}
```

### SnapPointAllocator

```cpp
namespace arborvia {

/// ìŠ¤ëƒ… í¬ì¸íŠ¸ ìë™ ë°°ë¶„ ì•Œê³ ë¦¬ì¦˜
class SnapPointAllocator {
public:
    struct SnapPoint {
        NodeId nodeId;
        PortSide side;
        Point position;           // ì ˆëŒ€ ì¢Œí‘œ
        float relativePosition;   // ë©´ ë‚´ ìƒëŒ€ ìœ„ì¹˜ (0.0~1.0)
        bool isOccupied = false;
        EdgeId occupyingEdge = INVALID_EDGE;
    };
    
    struct AllocationResult {
        std::unordered_map<NodeId, std::vector<SnapPoint>> snapPoints;
        std::unordered_map<EdgeId, std::pair<SnapPoint, SnapPoint>> edgeConnections;
    };
    
    /// ë…¸ë“œ ë ˆì´ì•„ì›ƒ ê¸°ë°˜ ìŠ¤ëƒ… í¬ì¸íŠ¸ ìƒì„±
    void generateSnapPoints(
        const std::unordered_map<NodeId, NodeLayout>& nodeLayouts,
        const EdgeRoutingOptions& options);
    
    /// ì—£ì§€ì— ìŠ¤ëƒ… í¬ì¸íŠ¸ í• ë‹¹
    AllocationResult allocate(
        const Graph& graph,
        const std::unordered_map<NodeId, NodeLayout>& nodeLayouts,
        const std::unordered_map<EdgeId, EdgeRoutingConfig>* configs = nullptr);
    
    /// íŠ¹ì • ë…¸ë“œì˜ ìŠ¤ëƒ… í¬ì¸íŠ¸ ì¡°íšŒ
    std::vector<SnapPoint> getSnapPoints(NodeId nodeId, PortSide side) const;
    
    /// ê°€ì¥ ê°€ê¹Œìš´ ë¹ˆ ìŠ¤ëƒ… í¬ì¸íŠ¸ ì°¾ê¸°
    std::optional<SnapPoint> findNearestAvailable(
        NodeId nodeId, 
        PortSide preferredSide,
        const Point& targetPoint) const;

private:
    EdgeRoutingOptions options_;
    std::unordered_map<NodeId, std::vector<SnapPoint>> nodeSnapPoints_;
    
    void distributeSnapPointsOnSide(
        const NodeLayout& node,
        PortSide side,
        int count);
    
    float calculateOptimalPosition(
        const NodeLayout& node,
        PortSide side,
        const Point& targetPoint);
};

}
```

### OrthogonalRouter

```cpp
namespace arborvia {

/// ì§êµ(ìˆ˜ì§/ìˆ˜í‰) ì—£ì§€ ë¼ìš°íŒ… êµ¬í˜„
class OrthogonalRouter : public IEdgeRouter {
public:
    OrthogonalRouter();
    explicit OrthogonalRouter(const EdgeRoutingOptions& options);
    
    // IEdgeRouter êµ¬í˜„
    void setOptions(const EdgeRoutingOptions& options) override;
    const EdgeRoutingOptions& options() const override;
    
    // [Primitive] ë‹¨ì¼ ì—£ì§€ ë¼ìš°íŒ…
    EdgeLayout route(
        const EdgeData& edge,
        const NodeLayout& from,
        const NodeLayout& to,
        const EdgeRoutingConfig* config = nullptr) override;
    
    // [Batch] ì„ íƒëœ ì—£ì§€ë“¤ ë¼ìš°íŒ…
    std::unordered_map<EdgeId, EdgeLayout> routeEdges(
        const std::vector<EdgeId>& edgeIds,
        const Graph& graph,
        const std::unordered_map<NodeId, NodeLayout>& nodeLayouts,
        const std::unordered_map<EdgeId, EdgeRoutingConfig>* configs = nullptr) override;
    
    // [Batch] ì „ì²´ ì—£ì§€ ë¼ìš°íŒ…
    std::unordered_map<EdgeId, EdgeLayout> routeAll(
        const Graph& graph,
        const std::unordered_map<NodeId, NodeLayout>& nodeLayouts,
        const std::unordered_map<EdgeId, EdgeRoutingConfig>* configs = nullptr) override;

private:
    EdgeRoutingOptions options_;
    SnapPointAllocator snapAllocator_;
    
    // ì§êµ ê²½ë¡œ ê³„ì‚°
    std::vector<Point> computeOrthogonalPath(
        const Point& source,
        const Point& target,
        PortSide sourceSide,
        PortSide targetSide);
    
    // ë²¤ë“œ í¬ì¸íŠ¸ ìµœì í™”
    std::vector<Point> optimizeBendPoints(
        const std::vector<Point>& path);
    
    // ë…¸ë“œ íšŒí”¼ ê²½ë¡œ ê³„ì‚°
    std::vector<Point> avoidNodes(
        const std::vector<Point>& path,
        const std::unordered_map<NodeId, NodeLayout>& nodeLayouts);
};

}
```

### ë¼ìš°íŒ… íŒŒì´í”„ë¼ì¸

```
ì…ë ¥: Graph + NodeLayouts + EdgeRoutingConfigs
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. ìŠ¤ëƒ… í¬ì¸íŠ¸ ìƒì„±                    â”‚
â”‚    - ê° ë…¸ë“œ ë©´ì— ìŠ¤ëƒ… í¬ì¸íŠ¸ ë°°ì¹˜      â”‚
â”‚    - EdgeRoutingOptions ê¸°ë°˜ ê°„ê²© ì„¤ì • â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. í¬íŠ¸ ì œì•½ ì²˜ë¦¬                      â”‚
â”‚    - EdgeRoutingConfigì˜ ì œì•½ ì ìš©     â”‚
â”‚    - ê³ ì • í¬íŠ¸ ìš°ì„  í• ë‹¹               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. ìŠ¤ëƒ… í¬ì¸íŠ¸ í• ë‹¹                    â”‚
â”‚    - ì—£ì§€ë³„ ìµœì  ìŠ¤ëƒ… í¬ì¸íŠ¸ ì„ íƒ      â”‚
â”‚    - ì¶©ëŒ ë°©ì§€ ë° ë¶„ì‚° ë°°ì¹˜            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. ê²½ë¡œ ê³„ì‚°                          â”‚
â”‚    - ì§êµ/í´ë¦¬ë¼ì¸/ìŠ¤í”Œë¼ì¸ ê²½ë¡œ ìƒì„±  â”‚
â”‚    - ë²¤ë“œ í¬ì¸íŠ¸ ìµœì í™”               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. ì¶©ëŒ íšŒí”¼ (ì„ íƒì )                  â”‚
â”‚    - ë…¸ë“œ í†µê³¼ ë°©ì§€                   â”‚
â”‚    - ì—£ì§€ êµì°¨ ìµœì†Œí™”                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
ì¶œë ¥: EdgeLayout (ì†ŒìŠ¤ì , íƒ€ê²Ÿì , ë²¤ë“œí¬ì¸íŠ¸)
```

### ì‚¬ìš© ì˜ˆì‹œ ğŸ“‹

> **ì°¸ê³ :** ì•„ë˜ ì˜ˆì‹œëŠ” routing ëª¨ë“ˆ êµ¬í˜„ ì™„ë£Œ í›„ ì‚¬ìš© ê°€ëŠ¥í•œ íŒ¨í„´ì…ë‹ˆë‹¤.
> í˜„ì¬ëŠ” SugiyamaLayoutì˜ ë‚´ì¥ EdgeRoutingë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.

```cpp
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// í˜„ì¬ ì‚¬ìš© ê°€ëŠ¥í•œ íŒ¨í„´ âœ…
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SugiyamaLayout layout;
LayoutResult result = layout.layout(graph);  // ì—£ì§€ ë¼ìš°íŒ… í¬í•¨

// LayoutResultì—ì„œ ì—£ì§€ ë ˆì´ì•„ì›ƒ ì¡°íšŒ
for (const auto& [edgeId, edgeLayout] : result.edgeLayouts()) {
    // sourcePoint, targetPoint, bendPoints ì‚¬ìš© ê°€ëŠ¥
    auto points = edgeLayout.allPoints();
    // ë Œë”ë§...
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// í–¥í›„ ì§€ì› ì˜ˆì • íŒ¨í„´ ğŸ“‹ (routing ëª¨ë“ˆ êµ¬í˜„ í›„)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// 1. ë…¸ë“œ ë“œë˜ê·¸ ì‹œ ì—°ê²°ëœ ì—£ì§€ë§Œ ì¬ë¼ìš°íŒ…
void onNodeDragged(NodeId nodeId, Point newPos) {
    // Step 1: ë…¸ë“œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ì• í”Œë¦¬ì¼€ì´ì…˜ ì±…ì„)
    nodeLayouts_[nodeId].position = newPos;
    
    // Step 2: Graphì—ì„œ ì—°ê²°ëœ ì—£ì§€ ì¡°íšŒ âœ… (í˜„ì¬ ì‚¬ìš© ê°€ëŠ¥)
    auto connectedEdges = graph_.getConnectedEdges(nodeId);
    
    // Step 3: í•´ë‹¹ ì—£ì§€ë§Œ ì¬ë¼ìš°íŒ… ğŸ“‹ (routing ëª¨ë“ˆ êµ¬í˜„ í›„)
    // auto updatedEdges = router_.routeEdges(
    //     connectedEdges, graph_, nodeLayouts_);
    
    render();
}

// 2. í¬íŠ¸ ì œì•½ ì ìš© ğŸ“‹ (routing ëª¨ë“ˆ êµ¬í˜„ í›„)
// EdgeRoutingConfig config;
// config.sourcePort.setSide(PortSide::Right).setPosition(0.5f);
// config.targetPort.setSide(PortSide::Left);
```

**ì„¤ê³„ ì² í•™:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  "Graphê°€ ì—°ê²° ì •ë³´ë¥¼, Routerê°€ ê²½ë¡œ ê³„ì‚°ì„ ë‹´ë‹¹"        â”‚
â”‚                                                         â”‚
â”‚  Graph.getConnectedEdges(nodeId)  â†’  ì–´ë–¤ ì—£ì§€?         â”‚
â”‚  Router.routeEdges(edges, ...)    â†’  ì–´ë–»ê²Œ ê·¸ë¦´ê¹Œ?     â”‚
â”‚  Application                      â†’  ì–¸ì œ, ì™œ?          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**í•µì‹¬:** SCE visualizer.htmlì˜ ìŠ¤ëƒ… í¬ì¸íŠ¸/ë²¤ë“œ í¬ì¸íŠ¸ ê¸°ëŠ¥ì„ C++ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë ˆë²¨ì—ì„œ ì§€ì›

---

## ğŸ“¤ ë ˆì´ì–´ 2: ì¶œë ¥ ëª¨ë“ˆ

**ë‹¤ì–‘í•œ í¬ë§·ìœ¼ë¡œ ë‚´ë³´ë‚´ê¸°**

### SvgExport

```cpp
struct SvgExportOptions {
    float padding = 20.0f;
    std::string backgroundColor = "white";
    
    // ë…¸ë“œ ìŠ¤íƒ€ì¼
    std::string nodeFill = "#e0e0e0";
    std::string nodeStroke = "#333333";
    float nodeCornerRadius = 5.0f;
    
    // Compound ë…¸ë“œ ìŠ¤íƒ€ì¼
    std::string compoundFill = "#f5f5f5";
    std::string parallelFill = "#f0f8ff";
    
    // ì—£ì§€ ìŠ¤íƒ€ì¼
    std::string edgeStroke = "#333333";
    
    bool showNodeLabels = true;
    bool showEdgeLabels = true;
};

class SvgExport {
public:
    std::string exportToString(const Graph& graph, const LayoutResult& layout);
    bool exportToFile(const Graph& graph, const LayoutResult& layout, 
                      const std::string& filename);
};
```

**í•µì‹¬:** SVGëŠ” í…ŒìŠ¤íŠ¸ìš©. ì‹¤ì œ ë Œë”ë§ì€ ì‚¬ìš©ì ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ LayoutResultë¥¼ í™œìš©.

---

## ğŸ”„ ë°ì´í„° íë¦„ ì˜ˆì‹œ

**ì‹œë‚˜ë¦¬ì˜¤: ìƒíƒœë¨¸ì‹ ì„ ë ˆì´ì•„ì›ƒí•˜ê³  ImGuië¡œ ë Œë”ë§**

```
1. ê·¸ë˜í”„ êµ¬ì„±:
   CompoundGraph graph;
   NodeId idle = graph.addNode("Idle");
   NodeId running = graph.addNode("Running");
   graph.addEdge(idle, running, "start");
   
2. ë ˆì´ì•„ì›ƒ ì‹¤í–‰:
   SugiyamaLayout layout;
   LayoutResult result = layout.layout(graph);
   
3. ë ˆì´ì•„ì›ƒ ê²°ê³¼ í™œìš©:
   for (auto& [id, nodeLayout] : result.nodeLayouts()) {
       // ImGui ë Œë”ë§
       ImVec2 pos(nodeLayout.position.x, nodeLayout.position.y);
       ImVec2 size(nodeLayout.size.width, nodeLayout.size.height);
       ImGui::GetWindowDrawList()->AddRect(pos, pos + size, color);
   }
   
   for (auto& [id, edgeLayout] : result.edgeLayouts()) {
       auto points = edgeLayout.allPoints();
       for (size_t i = 1; i < points.size(); ++i) {
           ImGui::GetWindowDrawList()->AddLine(
               {points[i-1].x, points[i-1].y},
               {points[i].x, points[i].y}, color);
       }
   }
```

**í•µì‹¬:** ArborViaëŠ” ì¢Œí‘œë§Œ ê³„ì‚°. ë Œë”ë§ì€ ì‚¬ìš©ì ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ì±…ì„.

---

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì „ëµ

### í…ŒìŠ¤íŠ¸ êµ¬ì¡°

```
tests/
â”œâ”€â”€ core/                       # í•µì‹¬ ìë£Œêµ¬ì¡° í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ GraphTest.cpp           # Graph í´ë˜ìŠ¤ í…ŒìŠ¤íŠ¸
â”‚   â””â”€â”€ CompoundGraphTest.cpp   # CompoundGraph í´ë˜ìŠ¤ í…ŒìŠ¤íŠ¸
â”œâ”€â”€ layout/                     # ë ˆì´ì•„ì›ƒ ì—”ì§„ í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ SugiyamaLayoutTest.cpp  # Sugiyama ì•Œê³ ë¦¬ì¦˜ í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ LayoutResultTest.cpp    # LayoutResult ì§ë ¬í™”/ì—­ì§ë ¬í™” í…ŒìŠ¤íŠ¸
â”‚   â””â”€â”€ ManualLayoutTest.cpp    # ìˆ˜ë™ ë ˆì´ì•„ì›ƒ í…ŒìŠ¤íŠ¸
â”œâ”€â”€ export/                     # ë‚´ë³´ë‚´ê¸° ëª¨ë“ˆ í…ŒìŠ¤íŠ¸
â”‚   â””â”€â”€ SvgExportTest.cpp       # SVG ë‚´ë³´ë‚´ê¸° í…ŒìŠ¤íŠ¸
â””â”€â”€ interactive/                # ì¸í„°ë™í‹°ë¸Œ ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸
    â””â”€â”€ DragBehaviorTest.cpp    # ë“œë˜ê·¸ ë™ì‘ ë° ìŠ¤ëƒ… í¬ì¸íŠ¸ í…ŒìŠ¤íŠ¸
```

### í…ŒìŠ¤íŠ¸ ëª…ëª… ê·œì¹™

`[Group_]Action_ExpectedResult` íŒ¨í„´ ì‚¬ìš©:

```cpp
// ê·¸ë£¹ ì ‘ë‘ì‚¬ë¥¼ í†µí•œ ëª…í™•í•œ ë¶„ë¥˜
TEST_F(DragBehaviorTest, Layout_InitialRouting_IsValid)
TEST_F(DragBehaviorTest, Drag_SingleNode_PreservesRouting)
TEST_F(DragBehaviorTest, Snap_DuringDrag_PointsDontMerge)
TEST_F(DragBehaviorTest, Mode_Unified_DistributesCorrectly)
```

### ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì˜ˆì‹œ

```cpp
// Graph í…ŒìŠ¤íŠ¸
TEST(GraphTest, AddNode_WithLabel_ReturnsValidId) {
    Graph graph;
    NodeId id = graph.addNode("test");
    EXPECT_TRUE(graph.hasNode(id));
}

// CompoundGraph í…ŒìŠ¤íŠ¸
TEST(CompoundGraphTest, SetParent_ValidNodes_EstablishesHierarchy) {
    CompoundGraph graph;
    NodeId parent = graph.addCompoundNode(CompoundType::Compound);
    NodeId child = graph.addNode("child");
    graph.setParent(child, parent);
    EXPECT_EQ(graph.getParent(child).value(), parent);
}

// Layout í…ŒìŠ¤íŠ¸
TEST(SugiyamaLayoutTest, ChainGraph_AssignsSequentialLayers) {
    Graph graph;
    NodeId n1 = graph.addNode("A");
    NodeId n2 = graph.addNode("B");
    graph.addEdge(n1, n2);
    
    SugiyamaLayout layout;
    LayoutResult result = layout.layout(graph);
    
    EXPECT_EQ(result.getNodeLayout(n1)->layer, 0);
    EXPECT_EQ(result.getNodeLayout(n2)->layer, 1);
}

// LayoutResult í…ŒìŠ¤íŠ¸
TEST(LayoutResultTest, ToJson_ContainsRequiredFields) {
    // JSON ì§ë ¬í™” ê²€ì¦
}

// SVG Export í…ŒìŠ¤íŠ¸
TEST(SvgExportTest, SimpleGraph_ProducesValidSvg) {
    // SVG ì¶œë ¥ ê²€ì¦
}
```

**í•µì‹¬ ì¥ì :** ë Œë”ë§ í”„ë ˆì„ì›Œí¬ ì—†ì´ ëª¨ë“  ë¡œì§ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ (95ê°œ í…ŒìŠ¤íŠ¸)

---

## ğŸ¨ í†µí•© ì˜ˆì‹œ

### Terraform Automata (SDL3 + ImGui)

```cpp
// terraform-automataì—ì„œ ArborVia ì‚¬ìš©
#include <arborvia/arborvia.h>

class StateMachineEditor {
    arborvia::CompoundGraph graph_;
    arborvia::LayoutResult layoutResult_;
    arborvia::SugiyamaLayout layout_;
    
public:
    void addState(const std::string& name) {
        graph_.addNode(name);
        relayout();
    }
    
    void addTransition(NodeId from, NodeId to) {
        graph_.addEdge(from, to);
        relayout();
    }
    
    void relayout() {
        layoutResult_ = layout_.layout(graph_);
    }
    
    void render() {
        // LayoutResultë¥¼ ì‚¬ìš©í•´ ImGuië¡œ ë Œë”ë§
        for (auto& [id, layout] : layoutResult_.nodeLayouts()) {
            renderNode(layout);
        }
        for (auto& [id, layout] : layoutResult_.edgeLayouts()) {
            renderEdge(layout);
        }
    }
};
```

---

## ğŸ“Š ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­

### ì‹œê°„ ë³µì¡ë„

| ì•Œê³ ë¦¬ì¦˜ ë‹¨ê³„ | ë³µì¡ë„ |
|--------------|--------|
| Cycle Removal | O(V + E) |
| Layer Assignment | O(V + E) |
| Crossing Minimization | O(iterations Ã— layers Ã— maxWidthÂ²) |
| Coordinate Assignment | O(V) |
| Edge Routing | O(E) |

**ì „ì²´:** O(V + E + iterations Ã— layers Ã— maxWidthÂ²)

### ìµœì í™” ì „ëµ

1. **ì‘ì€ ê·¸ë˜í”„ (< 100 ë…¸ë“œ):** ëª¨ë“  ê¸°ëŠ¥ í™œì„±í™”
2. **ì¤‘ê°„ ê·¸ë˜í”„ (100-1000 ë…¸ë“œ):** crossing minimization passes ê°ì†Œ
3. **í° ê·¸ë˜í”„ (> 1000 ë…¸ë“œ):** CrossingMinimization::None ì‚¬ìš©

---

## ğŸ“ ìš”ì•½

**4ê°œ í•µì‹¬ ëª¨ë“ˆ, ëª…í™•í•œ ì±…ì„:**

| ëª¨ë“ˆ | ì±…ì„ | ì¸í„°í˜ì´ìŠ¤ | ìƒíƒœ |
|------|------|-----------|------|
| **core/** | ê·¸ë˜í”„ ìë£Œêµ¬ì¡°, ê¸°ë³¸ íƒ€ì… | - | âœ… êµ¬í˜„ ì™„ë£Œ |
| **layout/** | ë…¸ë“œ ì¢Œí‘œ ê³„ì‚° | ILayout | âœ… êµ¬í˜„ ì™„ë£Œ |
| **export/** | ê²°ê³¼ ë‚´ë³´ë‚´ê¸° | IExporter | âœ… êµ¬í˜„ ì™„ë£Œ |
| **routing/** | ì—£ì§€ ê²½ë¡œ ê³„ì‚°, ìŠ¤ëƒ… í¬ì¸íŠ¸ | IEdgeRouter | ğŸ“‹ ì„¤ê³„ ì™„ë£Œ |

**í•µì‹¬ ì´ì :**

âœ… **ì œë¡œ ì˜ì¡´ì„±** - C++ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë§Œ ì‚¬ìš©  
âœ… **MIT ë¼ì´ì„¼ìŠ¤** - ìƒì—…ìš© ê²Œì„ì—ì„œ ììœ ë¡­ê²Œ ì‚¬ìš©  
âœ… **í”Œë«í¼ ë…ë¦½ì ** - ì–´ë–¤ UI í”„ë ˆì„ì›Œí¬ì™€ë„ í†µí•© ê°€ëŠ¥  
âœ… **í…ŒìŠ¤íŠ¸ ìš©ì´** - ë Œë”ë§ ì—†ì´ ëª¨ë“  ë¡œì§ í…ŒìŠ¤íŠ¸ (95ê°œ í…ŒìŠ¤íŠ¸)
âœ… **í™•ì¥ ê°€ëŠ¥** - ì¸í„°í˜ì´ìŠ¤ ê¸°ë°˜ìœ¼ë¡œ ìƒˆ ì•Œê³ ë¦¬ì¦˜ ì¶”ê°€ ìš©ì´  
âœ… **ëª¨ë“ˆí™”** - í•„ìš”í•œ ëª¨ë“ˆë§Œ ì„ íƒì  ì‚¬ìš© ê°€ëŠ¥  

**í™©ê¸ˆë¥ :**

> "ArborViaëŠ” ì¢Œí‘œë§Œ ê³„ì‚°í•©ë‹ˆë‹¤. ë Œë”ë§ì€ ì‚¬ìš©ìì˜ ëª«ì…ë‹ˆë‹¤."

---

## ğŸ—ºï¸ ë¡œë“œë§µ

### v0.3.0 (ë‹¤ìŒ ë²„ì „)
- ğŸ“‹ **routing/** ëª¨ë“ˆ êµ¬í˜„
  - IEdgeRouter ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
  - OrthogonalRouter êµ¬í˜„
  - SnapPointAllocator êµ¬í˜„

### v0.4.0 ì´í›„
- ğŸ“ Network Simplex ë ˆì´ì–´ í• ë‹¹
- ğŸ“ Spline ë¼ìš°í„°
- ğŸ“ ì¦ë¶„ ë ˆì´ì•„ì›ƒ
- ğŸ“ Force-Directed ë ˆì´ì•„ì›ƒ

---

**ë²„ì „:** 0.2.0  
**ìµœì¢… ì—…ë°ì´íŠ¸:** 2025-11-30  
**ìƒíƒœ:**
- âœ… Core ëª¨ë“ˆ êµ¬í˜„ ì™„ë£Œ (Graph, CompoundGraph)
- âœ… Layout ëª¨ë“ˆ êµ¬í˜„ ì™„ë£Œ (SugiyamaLayout)
- âœ… Export ëª¨ë“ˆ êµ¬í˜„ ì™„ë£Œ (SvgExport)
- ğŸ“‹ Routing ëª¨ë“ˆ ì„¤ê³„ ì™„ë£Œ, êµ¬í˜„ ì˜ˆì •
